Examples
========

Ha!  I'm telling you that this code generator can generate any text files that you desire, but I only have examples in one language (Java) and they output database access classes!  Just like every other "code generator" on Github! LOL

Anyway, as a server-side developer, I haven't really had any need for anything else yet.  That doesn't mean that you are limited in any way, but for the time being, you'll have to create your own templates.  I hope that if anyone ever discovers this project that they will start creating templates that others can use, too.  Until then, this is all I have.

On the other hand, they do use all of the tags and config files and have root template files as well as a number of different output template files.  To give you an idea of the different ways that you can do things, I have included to different versions of the template sets.  The primary differences are that the first group (`database`) does not use `typeConvert` or the `tab*` tags and the second group (`database_alt`) does.  If you generate all of the outputs and then diff them, the code should be identical except for places where the `tabStops` were used in the `database_alt` group.

Both groups each have two subsets of templates.  One (`combined_vo_dao_templates`) generates simplified database access classes that combine the value object (VO) and data access object (DAO) patterns into one class per table.  They work fine for stand-alone applications and I've used them for more than 10 years.  But if you try to use them in multiple apps that share a single database, you will have to add caching and cross-app synchronization (which I have done for a limited set of tables myself).  It worked, but it wasn't pretty.

That's where the second template group (`cached_templates`) comes in (sorta).  It separates the VO and DAO parts into separate classes (the more common way of doing things) and adds in the caching DAOs and the network API access classes to enable any number of apps to share a centralized cache.  *However*, this never got to production so it is not finished code.  On top of that, there are support classes that I haven't included in the utilities code so it will not even compile.  If you need something like this, then we can work together to polish it off and make it usable but for the time being, I'm going to leave it as-is.

The important thing I want you to get from the `cached_templates` is that you are not restricted to generating one type of file from a config values/template match-up.  The `cached_templates` not only have the database access classes, but they also have the network API classes and the JSON marshaling classes.  And if you diff the `Test_Database_Config_Values.xml` files between the two groups, you'll see that the only difference is the "`type`" because `database_alt` uses the `typeConvert` functionality and `database` does not.

As I point out in the overview, if a group of users agree on a config values file set, then they can create any number of template sets that output whatever functionality in any language and/or toolset combination possible.  You could, for example, build your database definition in the agreed format and then generate code for C++, Java, Python, Ruby, etc., etc., etc.  That way, regardless of what languages are used in your project/system, you could update all of their data access libraries with one generate after you make changes in either the config values or the templates.  Once you get to this point, you will be pretty floored how easy it makes things.

And this can be used for any other code you want, too.  You can define the config values and templates to output web or native GUIs, project setups, frameworks or network APIs.  I think the only limit is your imagination.  And the real power comes when you share your templates so that others can benefit from them.  Setting things up can be a pain, but once it's done, you and anyone you share your templates with can take advantage of it forever!

To that end, I will help as much as I can when you run into problems creating your templates.  But I will expect you to use these examples as a reference first.  Most of this is really easy to understand in small chunks, but it can get overwhelming once you've added a lot of tags to a large template.  And I've also tried to make the `codegenerator/docs` useful, too.  Try looking there for more discussion about each type of tag.
