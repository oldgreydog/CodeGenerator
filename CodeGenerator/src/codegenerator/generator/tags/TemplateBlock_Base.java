/*
	Copyright 2020 Wes Kaylor

	This file is part of CodeGenerator.

	CodeGenerator is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	CodeGenerator is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public License
	along with CodeGenerator.  If not, see <http://www.gnu.org/licenses/>.
 */


package codegenerator.generator.tags;



import coreutil.logging.*;

import java.io.*;
import java.util.*;

import codegenerator.generator.utils.*;



/**
	The base class API definition for all tag block subclasses.  Most tag blocks can contain child
	tags so this also provides the common functionality to add and evaluate child tags.
*/
public abstract class TemplateBlock_Base {

	// Data members
	protected	String							m_name					= null;
	protected	boolean							m_isSafeForTextBlock	= false;	// This is a simple flag that should elliminate the need to hard-code which tags are allowed inside a Text block.
	protected	LinkedList<TemplateBlock_Base>	m_blockList				= new LinkedList<TemplateBlock_Base>();
	protected	int								m_state					= -1;

	protected	int								m_lineNumber			= -1;		// The line number in the template file where this instance of a tag was defined.



	//*********************************
	public TemplateBlock_Base() {
		m_name = null;
	}


	//*********************************
	public TemplateBlock_Base(String p_name) {
		m_name = p_name;
	}


	//*********************************
	public boolean IsSafeForTextBlock() {
		return m_isSafeForTextBlock;
	}


	//*********************************
	/**
	 * The child class can grab any attributes from the tag parser to initialize itself.
	 *
	 * @param p_tagParser Generated by the parent block to parse this tag.  It contains all of the attribute definitions from the tag.
	 * @return
	 */
	public boolean Init(TagParser p_tagParser) {
		m_lineNumber = p_tagParser.GetLineNumber();

		return true;
	}


	//*********************************
	/**
	 * Used by {@link BlockFactory} to get a new instance of this handler class when it finds one that handles the requested tag.  This lets the instances held by the {@link BlockFactory} to act as Prototype-pattern objects.
	 *
	 * @return
	 */
	public abstract TemplateBlock_Base GetInstance();


	//*********************************
	public String GetName() {
		return m_name;
	}


	//*********************************
	/**
	 * As a child class that represents a tag that can contain other tags parses its content, it will
	 * add each new tag handler class here so that they can be evaluated in the original order.
	 *
	 * @param p_childBlock The newly parsed child tag handler.
	 */
	public void AddChildNode(TemplateBlock_Base p_childBlock) {
		m_blockList.add(p_childBlock);
	}


	//*********************************
	/**
	 * For tag blocks that can contain other tags, the child class will implement this to parse through
	 * that child content.
	 *
	 * @param p_tokenizer	Tokenizes the template input file so that it is easily processed by the handlers.
	 * @return
	 */
	public abstract boolean Parse(TemplateTokenizer p_tokenizer);


	//*********************************
	/**
	 * Creates the output for each node.  The base class implementation iterates through all of the
	 * child nodes that the child class implementation attached to itself during the Parse().  If a
	 * child class needs a different evaluation, then it can override this function.
	 *
	 * @param p_currentNode
	 * @param p_rootNode		Can be used to reach globals or other nodes that aren't part of the current node subtree.
	 * @param p_writer			The output stream to which all generated text is written.
	 * @param p_iterationCounter	The iteration counter for the inner-most enclosing <code>forEach</code> block.  Currently only used by <code>first</code> tags to know whether it is in the first iteration or not.  This must be an {@link java.util.concurrent.atomic.AtomicInteger} because you can't mutate regular int's or Integers.
	 * @return
	 * @throws Throwable
	 */
	public boolean Evaluate(EvaluationContext p_evaluationContext) throws Throwable
	{
		try {
			for (TemplateBlock_Base t_nextBlock: m_blockList) {
				if (!t_nextBlock.Evaluate(p_evaluationContext)) {
					return false;
				}
			}
		}
		catch (Throwable t_error) {
			Logger.LogException("TemplateBlock_Base.Evaluate() failed with error: ", t_error);
			return false;
		}

		return true;
	}


	//*********************************
	/**
	 * This is a helper function that can be used to evaluate attribute names and values and other instances where you know you need the string value locally and not in the p_writer stream.
	 * @param p_currentNode
	 * @param p_rootNode
	 * @param p_writer
	 * @param p_iterationCounter
	 * @return
	 */
	static public String EvaluateToString(TemplateBlock_Base	p_evalBlock,
										  EvaluationContext		p_evaluationContext)
	{
		try {
			if (p_evalBlock == null) {
				Logger.LogError("TemplateBlock_Base.EvaluateToString() received a NULL eval block.");
				return null;
			}

			StringWriter		t_valueWriter	= new StringWriter();
			Cursor				t_valueCursor	= new Cursor(t_valueWriter);

			p_evaluationContext.PushNewCursor(t_valueCursor);

			if (!p_evalBlock.Evaluate(p_evaluationContext)) {
				p_evaluationContext.PopCurrentCursor();	// We need to throw away the temp cursor now that we're done with it.
				return null;
			}

			p_evaluationContext.PopCurrentCursor();	// We need to throw away the temp cursor now that we're done with it.

			return t_valueWriter.toString();
		}
		catch (Throwable t_error) {
			Logger.LogException("TemplateBlock_Base.EvaluateToString() failed with error: ", t_error);
			return null;
		}
	}


	//*********************************
	/**
	 * Output descriptive information about the block for debugging purposes.  The output will show
	 * the tree representation of all of the block objects parsed from the template.
	 * @param p_tabs	A string containing the tab whitespace to be used in front of each line of
	 * the output so that the parent and child block definitions are spaced in a proper tree format.
	 *
	 * @return The string representation of this node's definition and the definitions of all of its
	 * child nodes.
	 */
	public String Dump(String p_tabs) {
		StringBuilder t_dump = new StringBuilder();

		if (m_name != null)
			t_dump.append(p_tabs + "Block type name :  " + m_name + "\n");

		for (TemplateBlock_Base t_nextBlock: m_blockList)
			t_dump.append("\n\n" + t_nextBlock.Dump(p_tabs + "\t"));

		return t_dump.toString();
	}
}
